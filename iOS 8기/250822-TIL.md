# 👩🏻‍💻 2025.08.22 Today I Learned:
1. 옵셔널
2. 옵셔널 언래핑
3. 중첩타입
4. 접근제어자
<br>



# Optional

```swift
struct Person {
	var name: String
    var age: Int
    var car: String // 모든 사람이 자동차를 갖고 있는가?
    
    func introduce() {
    	print("안녕하세요. 제 이름은 \(name)이고, 나이는 \(age)살입니다.")
    }
}

```

- Swift는 기본적으로 `nil(값없음)`을 헝용하지 않지만 개발을 하다보면 값이 없는 경우가 생기게 된다.
👉 이럴 때 사용하는 것이 `Optional`이다.

```swift
struct Person {
	var name: String
    var age: Int
    var car: String?
    
    func introduce() {
    	print("안녕하세요. 제 이름은 \(name)이고, 나이는 \(age)살입니다.")
    }
}
```
<br>

- `nil` 키워드는 `값이 없음`을 의미
- 값이 없을 수 있는 상태를 `옵셔널`이라고 하며, 옵셔널 타입은 `nil`로 저장할 수 있다.
- 기존 타입 뒤에 `?`를 붙인다.
	
    - 기본 타입 (Int, String, Float)
    - Collection Type (Array, Set, Dictionary)
    - Custom Type (`struct`, `class`, `enum`)
    - 익명함수인 `클로저`
- 값을 할당할 때는 기존의 타입과 동일하게 사용
- 옵셔널 타입의 값에 접근하면 `Optional`로 감싸진 것이 나오는데, 이를 `Optional로 래핑된 값`이라고 부른다.

<br>

## 선언 방법
```swift
💠 기본 타입 옵셔널 선언
var intValue: Int?
var stringValue: String?

💠 Collection Type 옵셔널 선언
var array: [String]?
var dictionary: [String: String]?

💠 Custom Type 옵셔널 선언
struct Person {
	let name: String
}

var optionalPerson: Person?

💠 클로저 옵셔널 선언
var closure: (() -> Void)?
```

<br>

## 사용 방법
```swift
//값을 할당할 때는 기존의 타입과 동일하게 사용
var intValue: Int? = 1

var stringValue: String?
stringValue = "안녕하세요"

var nilValue: String? = nil

struct Person {
	let name: String
}

var optionalPerson: Person? = Person(name: "Jihye")

var closure: (() -> Void)? = {
	print("Fire")
}

// 값에 접근하면 Optional로 래핑된 값이 나옴
print(intValue) // Optional(1)
print(stringValue) // Optional("안녕하세요")
print(nilValue) // nil
```

<br>

### 기본 타입과 연산 불가능
`옵셔널 타입`과 `기본타입`은 다른 타입이기 때문에 연산이 불가능하다.
- 비교 연산자 사용 가능

```swift
var intValue: Int? = 5

intValue += 5 // Error
```
- 옵셔널 언래핑 작업을 통해 기본 타입으로 변환하여 사용해야 함

<br>
<br>

## 옵셔널 체이닝 Optional Chaining
옵셔널 타입을 포함하는 복잡한 데이터 구조에서 옵셔널 값이 `nil`인지를 간결하게 체크하고 접근할 수 있는 방법
- 여러 중첩된 프로퍼티나 메소드 호출을 한줄로 처리할 수 있으며, 중간에 `nil`이 있는 경우 자동으로 `nil`을 반환
- 옵셔널 체이닝은 옵셔널 값에 대해 접근할 때마다 안전하게 처리 가능
- 옵셔널 값에 접근할 때 프로퍼티나 메서드 이름 뒤에 `?`를 붙여서 체이닝

```swift
struct Person {
	var name: String = "Default Name"
    var animal: Animal? // 반려동물이 있을수도, 없을수도 있다
}

struct Animal {
	let name: String
    var age: Int? // 언제 태어났는지 모를 경우
}

let person: Person? = Person(name: "Jihye", animal: nil)
print(person?.animal?.name) // nil - person은 옵셔널 값이어서 ?가 붙으며 animal?은 nil이므로 nil이 반환됨

let person2: Person(name: "Jihye", animal: Animal(name: "Dog", age: 5))
print(person2.animal?.name) // Optional("Dog")
```

```swift
let stringValue: String? = "안녕하세요"
print(stringValue?.count) // Optional(5)
```

<br>

`pseron?.animal?.name`
- 옵셔널 값에 `?`를 붙인 후 `.`을 사용하면 중첩된 프로퍼티나 메서드에 접근
- 중첩된 값 중 하나라도 `nil`이면 전체값을 `nil`로 반환
- 중첩된 값이 모두 `nil`이 아니라면 `Optional`로 래핑된 값 반환

<br>
<br>

 # 옵셔널 언래핑
 옵셔널로 래핑된 값에서 옵셔널을 제거하고 값으로 변환하는 과정
 - 옵셔널 바인딩
 - 기본값 제공
 - 강제 언래핑
 - 옵셔널 묵시적 언래핑
 
 <br>
 
## 옵셔널 바인딩 Optional Binding
 조건문 `if`, `guard` 구문을 사용하여 **안전하게 옵셔널을 언래핑**-
 
 <br>
 

### `if let`

 - 값이 있다면 `if let` 코드블록이 실행되고, 이 블록 안에서 언래핑된 값을 사용할 수 있다.
 - 값이 없을 때 작업을 하고 싶다면 `else` 코드블록을 작성하면 된다.
 
 
 <br>
 
💠 값이 있을 때 `if let` 옵셔널 바인딩 코드
 
```swift
 
 var intValue: Int? = 10
 
 if let intValue = intValue {
 	print(intValue) // 출력값: 10
 }
 
 print(intValue) // Optional(10)
 
```
 
 
 <br>
 
 
💠 값이 없을 때 `if let` 옵셔널 바인딩 사용하여 `else`에서 작업 진행

 
```swift
var optionalValue: String? // nil 상태
 if let optionalValue = optionalValue {
 	print(optionalValue) // optionalValue가 nil이 아니면 코드블록 실행 
} else {
	print("optionalValue 값은 nil입니다.")
}
```

<br>

### `guard let`
옵셔널 바인딩 결과가 `nil`일 경우, 해당 코드 블록을 빠져나가게 하여 이후 코드가 실행되지 않도록 함
- 클로저나 메서드 내부에서 주로 사용
- 코드의 가독성을 높이고 중첩된 조건문을 피할 수 있음

```swift
func guardLetFunction() {
	var optionalValue: String? // nil
    guard let optionalValue = optionalValue else {
    	print("guard 실행") // optionalValue가 nil이면 해당 블록 실행
        return
    }
    
    print(optionalValue) // 위의 guard let에서 함수 종료되어 실행되지 못함
}

guardLetFunction() // guard 실행
```

```swift
func guardLetFunction() {
	var optionalValue: String? = "Hello"
    guard let optionalValue = optionalValue else {
    	print("guard 실행")
        return // 함수를 종료하여 아래 코드로 내려가지 못하게
    }
}

guardLetFunction()
```

<br>

### 기본값 제공
Nil-결합 연산자(Nil-Coalescing Operator) 방법
- 옵셔널 값 뒤에 `??`를 붙인 후 기본값을 제공
- 옵셔널 값이 `nil`이면 `??` 뒤에 있는 기본 값 사용

```swift
let name: String? = nil
print(name ?? "Default Name) // Defualt Name

let greeting = "안녕하세요. \(name ?? "A")님!"
print(greeting) // 안녕하세요 A님!
```

<br>

### 옵셔널 강제 언래핑 Force Unwrapping
- 옵셔널 값에 `!`를 붙여 사용
- `nil`이 아니라면 언래핑이 되지만 `nil이면 런타임오류`를 발생
- `nil`이 아님을 확신할 때 사용 (지양하는 편이 좋음)

```swift
var name: String? = "Jihye"

print(name!) // Jihye

name = nil

print(name!) // 런타임 오류 발생
```

<br>

### 옵셔널 묵시적 언래핑 Implicitly Unwrapped Optional
- 옵셔널 타입을 선언할 때 `?`가 아닌 `!`를 사용하면 묵시적 언래핑 옵셔널로 정의
- 값을 사용할 때 자동으로 언래핑되어, 별도의 언래핑 없이 직접 사용
- 값이 `nil`일 때 접근하면 런타임 오류 발생
- 값이 있다고 확신이 들 때 사용
- 옵셔널 바인딩 가능

```swift
var name: String! = "Jihye" // String!으로 설정하여 묵시적 옵셔널 언래핑 사용

print(name) // Optional("Jihye")
print(name.count) // 5

if let name = name {
	print(name) // Jihye
}
```

<br>
<br>

# 중첩 타입 Nested Type
하나의 타입 안에 다른 타입을 정의

<br>

- 구조적으로 복잡한 클래스나 구조체 등을 더 조직적으로 관리 가능
- `class`, `struct`, `enum` 등에서 사용
- 중첩된 타입을 사용하면 코드의 가독성을 높이고 타입 간의 연관성을 명확히 할 수 있다.
- 타입의 블록 안에서 다른 타입을 정의하고 사용하는 방식으로 구현

```swift
struct Car {
  struct Company  {
    var name: String
    var phoneNumber: String

    func contact() {
        print("\(name) 회사의 A/S 센터 번호는 \(phoneNumber)입니다.")
    }
  }

  enum Model {
      case sedan
      case hatchback
      case suv
  }

  var model: Model
  var company: Company
  var name: String
  var color: String
}

let myCar =  Car(model: .sedan,
                company: Car.company(name: "스파르타!", phoneNumber: "000-0000-0000"),
                name: "붕붕이",
                color: "Black"

myCar.company.contact() // 스파르타! 회사의 A/S 센터 번호는 000-0000-0000입니다.
print(myCar.model) // model의 프로퍼티 출력
```

<br>
<br>

# 접근제어자
외부에서 코드에 대한 접근을 제한하는 기능 제공 <br>
접근을 제어함으로써 불필요한 정보의 노출을 막을 수 있다. <br>

```swift
struct Person {
  var name: String
  var age: Int
  var havingMoney: Int

  func introduce() {
      print("안녕하세요. 제 이름은 \(name)이고, 나이는 \(age)살입니다."
    }
}

var me = Person(name: "Jihye", age: 26, havingMoney: 10000)
print(me.havingMoney)
```


## Swift에서 제공하는 접근제어자 종류

### `open`
- 모든 외부 모듈에서 접근할 수 있는 접근제어자
- 가장 개방적인 접근 수준
- 유일하게 `class`에서만 사용 가능 👉 상속이 가능하고 재정의도 가능!

<br>

### `public`
- 모든 외부 모듈에서 접근할 수 있는 접근제어자
- 가장 개방적인 접근 수준

<br>

### `internal`
- `기본값` 접근제어자로 설정하지 않았을 때
- 동일한 모듈에서 접근 가능

<br>

### `fileprivate`
- 동일한 파일 내부에서만 접근할 수 있는 접근제어자

<br>

### `private`
- 가장 제한적인 접근제어자
- 해당 요소를 선언한 스코프(ex. `class`,  `struct`, `enum`)에서만 사용 가능
- `struct`에서 `private 프로퍼티`가 있다면 멤버와이즈 init을 사용할 수 없어서 직접 init을 작성해야 한다.

<br>
<br>

## 모듈
코드 배포의 단일 단위 <br>
Swift에서는 import를 사용하여 다른 모듈에서 가져올 수 있다.

<br>

```swift
struct Person {
  var name: String
  public var age: Int
  private var havingMoney: Int

  init(name: String, age: Int, havingMoney: Int) {
    self.name = name
    self.age = age
    self.havingMoney = havingMoney
  }

  private func printMoney() {
    print("나는 \(havingMoney)원 있다!")
  }

  func test() {
    printMoney()
  }
}

let person = Person(name: "Jihye", age: 20, havingMoney: 10000)


person.test() // 나는 10000원 있다!
/* test 함수는 Internal(default)라서 호출이 가능하다.
   test 함수 안에서는 private printMoney 함수에 접근이 가능하다.*/

person.age // public이므로 접근 가능

// ☠️ 빌드 오류 발생
person.havingMoney // private 프로퍼티이므로 접근 불가
person.printMoney() // private 메소드로 접근 불가
```

<br>

프로퍼티와 메소드 뿐만 아니라 `struct`, `class`, `enum`도 동일하게 사용 가능 !
<br>

```swift
public struct Person2 {

}

fileprivate class Animal {

}

private enum Season {

}
```

# 👩🏻‍💻 2025.08.20 Today I Learned:
1. 반복문
2. 함수
3. 고급 데이터 타입
4. 클로저
5. 자료 구조 기초

<br>

## 반복문
### `for`
`for in`을 사용하면 배열고 범위의 숫자를 반복


### `while`
조건이 `true`인 동안 코드블록 반복 실행
조건이 `false`가 되면 반복 종료

### 반복문 흐름제어
#### `break`
- 반복문이나 `switch`에서 즉시 종료하고, 코드블록을 빠져나올 때 사용
- 반복문에서 더이상 반복이 필요없을 때

#### `continue`
반복문 안에서 현재 반복을 건너뛰고 다음 반복으로 넘어갈 때

<br>
<br>

## 함수
### 함수의 선언
함수를 정의하는 과정
- 함수 선언의 4가지 요소
1. 함수의 이름
2. 파라미터(이름, 타입)
3. 반환 타입
4. 구현부

### 함수의 사용
정의한 함수를 호출하여 실제로 진행하는 과정
- 함수의 이름 뒤에 `()` 사용하여 함수 실행
- `()` 안에는 파라미터 삽입
- 함수를 사용하여 나온 결과값을 변수나 상수에 할당 가능

```
🪻 함수의 정의(선언)

func 함수이름(파라미터 이름: 파라미터 타입) -> 반환타입 {
	// 구현부
	return 반환 타입의 값
}

🪻 파라미터가 여러개인 경우
func 함수이름(파라미터1 이름: 파라미터1 타입, 파라미터2: 이름: 파라미터2 타입) -> 반환타입 {
	// 구현부
    return 반환 타입의 값
}

🪻 파라미터가 없는 경우
func 함수이름() -> 반환 타입 {
	// 구현부
    return 반환 타입의 값
}

🪻 반환값이 없는 경우
func 함수이름(파라미터 이름: 파라미터 타입) {
	// 구현부
    // 반환타입이 없기때문에 return이 없어도 됨
    // 반환타입이 없는데 중간에 함수를 탈출하고 싶으면 return tkdyd
}

🪻 파라미터가 없고 반환값도 없는 경우
func 함수이름() {
	// 구현부
}
```

<br>

### 함수 파라미터 이름의 분리
- 함수의 구현부에서 사용하는 이름과 함수 호출할 때 사용하는 이름을 다르게 설정 가능
- 기본적으로 함수의 선언부에서 정한 파라미터의 이름은 함수의 구현부와 호출부에서 동일하게 사용됨

```
func sayHello(name: String) {
	print("\(name)님 안녕하세요.")
}

sayHello(name: "수강생")
```
Swift에서는 구현부에서 사용하는 파라미터의 이름과 호출부에서 사용하는 파라미터의 이름을 다르게 할 수 있다.
- 첫 번째 이름: 함수를 호출할 때 사용하는 이름
- 두 번째 이름: 함수 구현부에서 사용하는 이름

```
// 스페이스로 띄우고 파라미터 이름을 2개 입력하면 호출, 구현부에서 사용하는 이름을 정할 수 있다.
func sayHello(to name: String) {
	print("\(name)님 안녕하세요.")
}

// 파라미터의 이름이 2개 있을 때 첫 번째 값이 호출할 때 사용하는 이름
sayHello(to: "수강생")

// _를 사용하여 파라미터의 이름 생략
func sayBye(_ name: String) { // 파라미터 이름 2개 (_, name)
	print("\(name)님 안녕히가세요.")
}

sayBye("수강생")
```

<br>
<br>

## 고급 데이터 타입
### `Array`
동일한 데이터 타입의 여러 개 값을 순서대로 저장하는 데이터 타입

#### 배열의 반복문
```
var array = [1, 2, 3, 4, 5, 6]

for value in array {
	print(value)
}

for index in 0..< array.count {
	print("Index: \(index), Array Value: \(array[index])")
}
```

<br>

### `Set`

순서와 상관없이 같은 타입의 다른 값을 저장
- 순서가 없음
- 중복 허용 금지
- 저장할 타입 명시해줘야 함
- 중복된 값 입력시 무시

```
var emptySet: Set<String> = []
var emptySet = Set<String>()
```

<br>

### `Dictionary`
순서와 상관없이 키(`key`)와 값(`value`)의 쌍으로 데이터를 저장하는 컬렉션 타입
- 순서가 없음
- `key`는 중복을 허용하지 않고 중복된 `key`에 새로운 값을 할당하면 `value`가 최신값으로 업데이트
- `[ ]` 대괄호 안에 `:`을 기준으로 `key`, `value`를 나누어서 사용
- `key` 값에 접근하려면 대괄호 안에 `key`값 넣기

```
var emptyDictionary: [String: Int] = [:]
var emptyDictionary2 = [Int: String]()
```

<br>
<br>

## 클로저
- `익명함수` 함수와 유사하게 특정 작업을 수행하는 코드블록
- 함수의 4가지 요소 (`이름`, `파라미터`, `반환타입`, `구현부`)에서 `이름`을 제외한 `파라미터`, `반환타입`, `구현부`로 구성
- 데이터 타입으로클로저 사용
	
    - 변수에 할당하여 재사용 가능
    - 함수의 파라미터로 전달

#### 타입으로 사용하는 방법
```
(파라미터 데이터 타입) -> 리턴 타입
```
- 파라미터의 타입은 없을 때 비워두고, 리턴 타입이 있는 경우 `Void`라고 명시. 파라미터가 없을 때도 `()` 괄호는 있어야 함.
- 데이터 타입으로 사용할 수 있기 때문에 `Optional` 타입으로 사용. 전체를 `()`로 감싼 후 `?`를 입력
```
let closure: (Int, String) -> Void 
👉 파라미터는 튜플(Int, String) 타입이고 반환타입은 없음

let closure2: (Int) -> Void        
👉 파라미터는 1개로 Int이며 반환타입은 없음

let closure3: () -> Void          
👉 파라미터는 없고 반환타입도 없음
👉 파라미터는 ()로 감싸고 있어서 Void를 생략가능

let closure4: (Int) -> Int         
👉 파라미터는 1개이고 Int 타입이며, 반환값은 Int

let closure5: (String, Int) -> Int 
👉 파라미터는 튜플(String, Int) 타입이고 반환타입은 Int 

let optionalClosure: ((Int) -> Int)? 
👉 옵셔널 타입
👉 만약 ()가 없었다면 리턴값이 Int? 라고 판단
```

#### 구현 방법
```
{ 파라미터 이름 in 
	// 구현부
    // 리턴
}
```
- `in`  키워드를 사용하여 앞에는 파라미터 이름을 뒤에는 구현부를 분리하여 작성
- 파라미터 이름은 생략 가능하며 0번째 파라미터 `$0` 으로 사용 가능  (`$0`, `$1`, `$2` …) 파라미터 이름을 생략할 때는 `in` 키워드까지 생략
- 파라미터가 없다면 `in` 을 생략

<br>

#### 클로저를 사용(호출)하기
- 변수나 상수에 클로저를 저장했다면 함수처럼 이름뒤에 괄호 사용
- 옵셔널 변수에 저장한 클로저는 `변수이름?()` 형식으로 사용
- 구현하고 즉시 호출한 결과값을 저장하고 싶다면 `{}` 뒤에 괄호 `()` 사용하기

```
let closure: (Int, String) -> Void = { intValue, stringValue in 
	print(intValue)
    print(stringValue)
}

closure(10, "20")
```

```
옵셔널 변수에 저장한 클로저 호출

let optionalClosure: ((Int) -> Int)? = {
	return $0 * 2
}

print(optionalClousre?(10))
```

```
구현하고 바로 호출

let helloClosure = {
	return "Hello"
}()

print(helloClosure)
```

<br>
<br>

## 자료 구조 기초
CPU: 중앙처리장치. 프로그램의 연산을 실행하고 처리하는 하드웨어이며, 메모리에 저장된 데이터를 직접 처리

#### 메모리?
프로그램이 실행될 때 데이터를 저장하는 임시 공간

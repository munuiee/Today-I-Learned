# 👩🏻‍💻 2025.08.13 Today I Learned:

1. UIStackView
2. 깃허브 main branch 업로드
3. 깃허브 프로젝트 가져오기
4. 깃허브
<br>
<br>
<br>

## 💠 UIStackView
오늘 우리가 만드는 미니 프로젝트의 main 화면을 수정하면서 UIKit를 스토리보드가 아닌 코드로 오토레이아웃을 시도하게 되었고 UIStackView를 알게 되었다.

### UIStackView❓
Auto Layout을 이용해 열 또는 행에 View들의 묶음을 배치할 수 있는 간소화된 인터페이스
```
stackView.axis = .vertical
        stackView.spacing = 15
        stackView.alignment = .leading
        
        stackView.translatesAutoresizingMaskIntoConstraints = false
```

<br>
<br>

## 🤓 깃허브 main branch 업로드
오늘은 내 브랜치가 아닌 main으로 사용하는 브랜치에 업로드를 하게 되었다.

`cd /Users/파일 경로`
터미널 파일 경로를 먼저 바꿔준다.

`git add .`
업로드할 파일 추가

`git commit -m "커밋메세지"`
커밋하기

`git remote add origin(원격저장소) 깃허브주소`
레퍼지토리에 프로젝트 추가

`git push origin 브랜치이름`
커밋할 파일 push

#### ⚠️ There is no tracking information for the current branch. Please specify which branch you want to rebase against.
오류가 안 날리가 없겠죠.. 이건 현재 브랜치가 원격 브랜치와 연결이 안 돼서 뜨는 에러라고 한다. push가 안 돼서 pull, rebase 입력했다가 이런 오류가 뜸.
이건 간단하게 해결했다!
`git branch --set-upstream-to=origin/브랜치이름
`
이걸 입력해주니 _branch 'main' set up to track 'origin/브랜치이름_'이 떴고 다시 `git add .`부터 해주니 성공

<br>
<br>

## 👛 깃허브 프로젝트 가져오기
원격저장소에 있는 프로젝트를 로컬저장소로 가져오는 방법
1️⃣ `git push`
2️⃣ `git fetch`
3️⃣ `git clone`

나는 오늘 `git clone`을 써서 프로젝트를 가져왔지만 공부용으로 다른 방법들도 함께 메모..✎

#### 1. `git pull`
`git pull` = `git fetch` + `git merge`
pull과 fetch는 병합을 하냐, 안 하냐의 차이

원격저장소에 있는 프로젝트의 변경사항을 그대로 로컬저장소에 옮겨와 자동으로 병합
👉 변경사항을 가져옴과 동시에 자동으로 병합이 되기 때문에 무엇이 추가되고 병합되었는지 확인불가

#### 2. `git fetch`
원격저장소에 있는 프로젝트의 변경사항을 가져오기만 한 후 병합(merge)는 따로
👉 다른 사람이 수정한 부분을 확인하고 병합 가능

#### 3. `git clone`
원격저장소의 내용을 새로운 폴더에 그대로 복사

1️⃣ 터미널에서 `cd`로 clone할 저장소 폴더로 이동
2️⃣ clone할 원격저장소 주소 복사
3️⃣ `git clone 깃허브주소` 입력


<br>
<br>

## 🛝 깃허브

### Github
Git 저장소를 온라인에서 관리할 수 있게 해주는 웹 기반 플랫폼

#### How To USE❓
🔧 `git init`
- 새로운 로컬 Git Repository 생성
- .git 디렉토리가 생성되고 해당 폴더에서 모든 변경사항이 Git으로 관리되기 시작
- 원격저장소가 없고 원격저장소에 코드를 올리려면 동기화 작업 필요

🔧 `git clone`

- 원격저장소를 복제하여 로컬 저장소로 가져옴
- 이미 존재하는 원격 저장소에서 프로젝트를 내려받아 로컬에서 작업을 시작할 때 사용
- `push`, `pull` 등을 사용하여 원격저장소와 로컬저장소의 싱크를 맞춰야 함

🔧 브랜치(branch)
- 독립적인 작업 흐름 관리
- 처음에 Git Repository를 만들면 main 또는 master 브랜치가 기본 생성됨
	
    - `git branch`: 브랜치 목록 확인
    - `git branch 새로운브랜치이름`: 브랜치 생성
    - `git switch 브랜치이름`:  작업 중인 브랜치 변경
   
🔧 변경사항 업데이트
- `git add`: 변경사항을 스테이지에 업로드
- `git commit`: 스테이지 영역에 올라온 변경사항 저장
- `git fetch`: 원격 저장소의 변경 사항을 로컬로 가져오지만 병합하지 않음
- `git pull`: 다른 브랜치의 변경사항 가져옴
- `git push`: 변경사항을 다른 저장소로 업로드

<br>

### 브랜치 병합
#### Pull Request
- 브랜치의 작업물을 다른 브랜치에 병합할 때 확인(requet) 받고 하기
- 관리하는 브랜치에 다른 사람의 브랜치가 병합된다면 오류날 확률 높아짐
- 이를 막고자 Pull을 요청하고 확인 후에 합치는 기능

#### Conflict(충돌)
동일한 파일의 동일한 위치에 2명의 개발자가 코드를 변경했다면 Git은 각 개발자의 코드 중 어떤 걸 사용해야 될 지 결정할 수 있음
⚠️ 이럴 때 충돌 발생

#### 병합 방법

#### 1. `Rebase`
- 다른 브랜치의 최근 커밋 내용 뒤에 현재 브랜치의 커밋 재정렬
- 깔끔한 커밋 히스토리 유지 가능
- 불필요한 Merge Commit을 생성하지 않음
- 충돌 발생 시 해결이 복잡해지며, 협업 브랜치에서는 사용주의
- 작업했던 커밋을 복사해서 붙이는 방식

#### 2. `Merge`
- 기본 커밋 히스토리를 유지하면서 새로운 Merge 커밋을 만들어서 병합
- 기존 브랜치의 히스토리 유지
- 병합 후에도 원래 브랜치의 기록이 남아서 이력이 복잡해질 수 있음
- 협업 시 누가 어떤 작업을 했는지 명확하게 남길 수 있음

#### 3. `Squash`
- 여러개의 커밋을 하나로 합침
- 작은 변경사항이 많은 경우 커밋 정리 가능
- 깔끔한 커밋 히스토리 유지
- 협업 시 자잘한 커밋들을 하나로 합쳐서 유지
- 하나의 큰 Feature을 Sub Feature로 나눠서 작업하고 합치는 데 유용

### 브랜치 전략

#### 1. `Github Flow`
- main branch를 기준으로 새 브랜치 생성
- release, develop 등의 세부적인 브랜치가 없음
- 메인 브랜치에서 필요한 브랜치를 만들어서 개발하고 병합하기 때문에 매우 간편

🤦🏻‍♀️단점
- 대규모에서 사용하게 된다면 업데이트가 잦기 때문에 컨플릭 확률 높아짐
- 브랜치의 룰이 명확하지 않아서 커밋 메세지를 잘 남겨야함 (그래도 쉽지 않음)


#### 2. `Git Flow`
- 브랜치 이름을 보면 어떤 작업인지 한눈에 확인 가능
- master에 태그를 사용하여 버전 태깅을 하면 버전별 이슈에 대응하기 쉬움

🤦🏻‍♀️단점
- 브랜치가 많아지기 때문에 관리 복잡
- 머지가 많아지기 때문에 머지 커밋 역시 많이 쌓임

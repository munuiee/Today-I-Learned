# 👩🏻‍💻 Today I Learned:
1. 열거형
2. 인스턴스
3. 클래스
4. struct
5. 프로퍼티
6. 메소드
7. LinkedList

<br>
<br>


## enum(열거형)
- 관련된 값을 그룹화
- `enum` 키워드와 코드블록을 사용하여 정의
	
    - 그룹화된 값은 enum의 코드블록 내에서 `case`를 사용하여 정의
- 타입 안정성 보장, 명확한 의도 파악 가능
- 정의한 enum은 `데이터 타입`으로 사용할 수 있음
- `enum`을 사용하여 만들어진 인스턴스는 `Value Type`

<br>


### Associated Values (연관값)
- 단순히 여러 값을 나열하는 것 이상의 기능 제공
- 추가적인 정보를 연관시켜 저장
- 각 `case`와 함께 타입을 지정하여 선언하면 연관값을 가질 수 있음


<br>

### Raw Values (원시값)
- 각 `case`마다 기본으로 설정된 원시값을 저장할 수 있음
- `enum` 이름 뒤에 콜론`:`을 작성한 후 **타입을 명시**
- `case` 뒤에 `=`을 사용하여 원시값을 정함
- rawValue를 사용하여 enum의 값을 만들 수 있으며, 이때 매칭되는 rawValue가 없을 수 있기 때문에 Optional 값으로 나옴

<br>

### Raw Values가 될 수 있는 자료형
1️⃣ Number Type 
2️⃣ Character Type - 모든 case에 대한 Raw Value를 직접 선언해야 함 
3️⃣ String Type 

<br>
<br>



## 인스턴스 (Instance)
`class`, `struct`, `enum`과 같은 설계도를 기반으로 실제 메모리에 생성되는 실체 <br>
**`class`, `struct`, `enum`은 설계도**의 역할을 하고, **인스턴스는 설계도를 보고 직접 만들어서 메모리에 저장되어 있는 값**이다. 

<br>

### 객체
인스턴스의 다른 말
인스턴스가 생성된 후 클래스에서 제공하는 프로퍼티나 메서드를 사용할 때 주로 사용

<br>

### 프로퍼티 (Property)
`class`, `struct`, `enum`과 관련되어 있는 정보 또는 값

<br>

### 메서드 (Method)
`class`, `struct`, `enum`과 관련된 함수

<br>

### `init`
인스턴스를 생성할 때 상태를 초기화하여 생성해야 한다. <br>
인스턴스를 만들 때 사용되는 변수, 상수(프로퍼티)의 값을 정해주어야 한다.

- 프로퍼티를 넣어서 초기화하여 생성한다.
- `init` 키워드를 사용하여 모든 변수, 상수를 초기화 해야 한다.
- 변수나 상수에 기본값을 정해주거나 값이 없음을 나타내는 Optional 타입으로 선언하면 초기화하지 않아도 된다.


<br>
<br>

## class
연관된 상태는 변수, 상수에 저장하고 행동은 함수를 정의한 후 그룹화하여 `데이터타입`으로 사용할 수 있다.

<br>

### 특징
- `프로퍼티`와 `메소드`로 구성
	
    - `프로퍼티`: 구조체, class 안에 있는 변수 , 상수
    - `메소드`: 구조체, class 안에 있는 함수
- class의 인스턴스를 생성하여 사용
- class 안에서 사용되는 변수와 상수인 `프로퍼티`에는 `default` 값을 정해줄 수 있음
- class의 인스턴스를 생성할 때 반드시 초기화를 해주어야 함
- `init` 초기화를 제공
	
    - 모든 프로퍼티에 default 값을 제공한다면 `init` 초기화 생략 가능
    - 모든 프로퍼티가 `Optional`인 경우 `init` 초기화 생략 가능
- 초기화를 도와주는 컨비니언스 이니셜라이저(Convenience Initaializer)를 제공
- class를 사용해서 만들어진 인스턴스는 `Reference Type`이다.
	
    - 인스턴스를 `let`으로 만들어도 프로퍼티 변경이 됨
    - 함수에 class의 인스턴스를 전달하고 프로퍼티를 변경하면 원본도 변경됨
- `상속` 가능
	
    - 하위클래스가 상위클래스의 속성(프로퍼티)와 행동(메소드)를 물려받아서 사용 가능
    

### `init` (초기화) 방법
인스턴스를 생성할 때 모든 프로퍼티를 초기화해야 하며, 이를 위해 `init` 키워드를 사용

<br>

#### `class`에서 `init`
- 모든 프로퍼티의 값을 할당하기
	
    - `값이 없을 수 있는 옵셔널 타입`, `초기값을 준 프로퍼티`는 예외
- `init`을 여러개 만들 수 있음
- `convenience init`(보조 초기화) 기능 제공 (struct에서는 제공하지 않음)

<br>

#### 초기화 방법

<br>

1️⃣ 지정 초기화
클래스에서 가장 핵심이 되는 초기화 함수
- 모든 프로퍼티를 제대로 채우고, 부모 클래스 것도 챙겨서 위로 연결


2️⃣ 기본값 초기화
- 프로퍼티에 기본값을 넣으면 초기화를 진행하지 않아도 된다.

3️⃣ 여러개의 `init` 사용
- 여러가지 방법으로 초기화

4️⃣ `covenience init`: 보조 초기화
 - 클래스에서만 사용 가능
 - `self.init`을 사용하여 초기화를 도와줌
 
 <br>
 

 
 #### `deinit`: 소멸자
- class에서만 사용 가능
- 사용이 종료된 인스턴스가 메모리에서 해제될 때 자동 호출
- 직접 호출 불가
 
 <br>
 <br>
 
 
## Struct
연관된 상태는 변수, 상수에 저장하고 행동은 함수를 정의한 후 그룹화하여 `데이터타입`으로 사용

<br>

### 특징
- `프로퍼티`와 `메소드`로 구성
- 구조체의 인스턴스르 생성하여 사용
- 구조체 안에서 사용되는 변수와 상수인 프로퍼티에는 `default` 값을 정해줄 수 있음
- Memberwise Initializer(멤버와이즈 이니셜라이저)를 제공
	
    - 직접 `init`을 정의하지 않아도 모든 프로퍼티의 초기화를 자동으로 생성해주는 기능
- 구조체를 사용하여 만들어진 인스턴스는 `Value Type`
	
    - 구조체의 인스턴스는 값이 복사 되므로, 서로 다른 값으로 처리됨
- 메소드에서 프로퍼티를 변경하려면 `mutating` 키워드를 사용
- `상속` 불가능
- 인스턴스를 `let`으로 만들면 내부 프로퍼티 변경 불가

<br>

### 초기화 방법
- 모든 프로퍼티의 값을 할당해주어야 한다.
	
    - `값이 없을 수 있는 옵셔널 타입`, `초기값을 준 프로퍼티`는 예외
    - `init`을 여러개 생성 가능
    - Memberwise init 제공
    

<br>

1️⃣ `memberwise init` 사용
- 자동으로 `init` 생성

2️⃣ 기본값 초기화

3️⃣ 지정 초기화
- `init`을 직접 생성하면 `memberwise init`이 사용되지 않음

4️⃣ 여러개의 `init` 사용

<br>
<br>
 

## Property
`class`, `struct`, `enum` 등에서 사용되는 변수나 상수

<br>

### 저장 프로퍼티 Stored Property
데이터를 저장하는 프로퍼티
- `var`와 `let` 모두 사용 가능
- `class`, `struct` 등에서 데이터를 저장하기 위한 변수와 상수
- `enum`에서는 저장 프로퍼티 사용 불가 (빌드 오류 발생)
- 초깃값을 가질 수 있다
- 초기화 필수! 기본값을 주거나 `init`에서 넣기

### 연산 프로퍼티 Computed Property
값을 직접 저장하지 않고 계산된 값을 제공하는 프로퍼티
계산해서 값을 주거나(`set`), 가져오거나(`get`)하는 프로퍼티
- `class`, `struct`, `enum` 등에서 사용 가능
- `var`만 사용 가능 (동적으로 계산하여 값을 반환)
- `getter`와 `setter`를 사용하여 동적으로 값 계산
	-
    - `getter`: `get` 키워드를 사용하여 코드블록을 구현
    - `setter`: `set` 키워드를 사용하여 코드블록 구현
- `getter`은 필수
- `setter`을 구현하지 않았다면 `get` 키워드 생략 가능
<br>

#### `get`
- 값을 가져올 때 동작
- 값을 리턴해야 함
- 생략 가능


#### `set`
- 값을 설정할 때 동작
- 자동으로 `newValue`라는 이름의 값이 들어옴
- 원하면 `set(커스텀이름)` 이렇게 이름 지정 가능

<br>

### 타입 프로퍼티 Type Property
모든 인스턴스가 공유하는 프로퍼티, 인스턴스를 만들지 않고 타입 자체에서 접근이 가능
- `static` 키워드를 사용
- `class`, `enum`, `struct` 사용 가능
- `타입이름.타입프로퍼티_이름` 형태로 접근
- `static` 키워드로 선언 (오버라이드 불가)
- 오버라이딩 허용 👉 클래스에서만 `class` 키워드 써도 됨

<br>

### 프로퍼티 옵저버 Property Observers
`저장 프로퍼티`의 값이 변경되는 것을 감시하고 있다가 코드블록을 실행할 수 있는 기능
- `저장 프로퍼티` 타입 뒤에 코드블록을 작성하여 생성
- `저장 프로퍼티`가 사용 가능한 `struct`, `class`에서 사용 가능
- `willSet`, `didSet`을 제공. 둘 중 하나만 작성해도 OK

#### `willSet`
- 값이 변경되기 전에 호출
- 변경될 값은 `newValue`를 통해 접근하며, 이름을 정할 수 있음
- 이름을 정하려면 `willSet(이름)` 형식으로 작성

<br>

#### `didSet`
- 값이 변경된 후 호출
- 변경되기 전의 값은 `oldValue`를 통해 접근하며, 이름을 정할 수 있음
- 이름을 정하려면 `didSet(이름)` 형식으로 작성

<br>

### 지연 저장 프로퍼티 Lazy Stored Property
처음 사용하기 전까지 실제로 메모리에 값을 저장하지 않는 지연된 저장 프로퍼티
- 사용하기 전까지 값을 저장하지 않기 때문에 메모리 효율을 높일 수 있음
- `lazy` 키워드 사용 `lazy var 프로퍼티이름`
- `var`에서만 사용 가능
- `class`, `struct` 사용

<br>
<br>

## Method
`class`, `struct`, `enum` 등에서 사용되는 함수
- 인스턴스 메서드
- 타입 메서드

<br>

### 인스턴스 메서드 Instance Method
인스턴스를 통해서 호출

#### 인스턴스 메서드에서 프로퍼티 변경하기
인스턴스가 `Reference Type`, `Value Type`에 따라서 프로퍼티를 변경하는 방법이 나누어짐

<br>

### Reference Type
`class`로 만들어진 `인스턴스`는 `Reference Type`이므로 인스턴스 메서드에서 프로퍼티 값을 직접 변경 가능

### Value Type
`struct`, `enum`은 `value type`이므로, 인스턴스 메서드에서 프로퍼티를 직접 변경할 수 없으며 수정하려면 `mutating` 키워드를 사용해야 한다.

<br>


### 타입 메서드 Type Method
`타입 프로퍼티`와 마찬가지로 인스턴스를 만들지 않고 호출
- `static` 키워드 사용
- `class`, `struct`, `enum` 등에서 사용
- 함수 내부에 있는 타입 프로퍼티에만 접근 가능. 인스턴스를 만들지 않고 사용하기 때문에 다른 프로퍼티에는 접근 불가

<br>
<br>

## LinkedList
자료구조 중 하나로 데이터 요소를 연결된 노드로 표현하는 방식 <br>
노드(Node)라는 작은 조각들이 포인터로 서로 연결된 구조 <br>
- 각 노드는 데이터와 다음 노드를 가리키는 포인터(또는 링크)로 구성되며, 이 포인터르 통해 다음 노드로 이동하면서 데이터에 순차적으로 접근할 수 있다.
- 동적으로 크기가 조절될 수 있으며, 데이터의 삽입과 삭제가 빠르게 이루어진다.

<br>

### 기본 개념
- 노드(Node): LinkedList의 기본 구성 요소. 데이터와 다음 노드를 가리키는 링크(포인터)로 구성됨
- 헤드(Head): LinkedList의 첫 번째 노드를 가리키는 포인터. LinkedList에서 데이터에 접근하기 위해서는 헤드부터 시작해야 한다.
- 데이터(Data): 각 노드가 저장하는 실제값 또는 객체
- 링크(포인터/Pointer): 노드들을 연결. 각 노드는 다음 노드를 가리키는 링크를 가지고 있음.

<br>

### 장점
- 빠른 삽입과 삭제 <br>
각 노드가 다음 노드를 가리키는 링크를 가지고 있기 때문에 삭제 연산이 노드의 재배치 없이 수행될 수 있다. 따라서 배열과 달리 데이터의 이동이 필요 없으므로 시간복잡도가 O(1)에 가깝다. 중간 위치에 노드를 삽입하거나 삭제하는 작업 또한 배열보다 훨씬 효율적이며, 중간 위치에 대한 포인터 조정만으로 해당 작업을 수행할 수 있다.

- 용이한 동적 크기 조절 <br>
노드의 동적인 삽입과 삭제가 가능하므로, 크기를 실시간으로 조절할 수 있다. 데이터의 추가 또는 삭제에 따라 메모리를 유연하게 할당하고 해제할 수 있어서 메모리를 효율적으로 관리할 수 있다.

<br>

### 단점
- 임의 접근의 어려움 <br>
데이터에 순차적으로 접근하는 것이 효율적이다. 따라서 특정 위치의 데이터에 접근하려면 처음(Head)부터 순차적으로 탐색해야 한다. 이로 인해 임의 접근이 필요한 작업은 성능이 떨어질 수 있다. O(n)의 시간복잡도가 소요된다.

- 추가적인 메모리 공간이 필요 <br>
각 노드마다 다음 노드를 가리키는 포인터를 유지해야 한다. 따라서 배열에 비해 추가적인 메모리 공간이 필요하며, 이로 인한 메모리 사용량이 더 많을 수 있다.

- 긴 검색 시간 <br>
데이터를 순차적으로 접근해야하므로 특정 요소를 찾기 위해서는 처음부터 시작하여 찾고자 하는 요소를 찾을 때까지 노드를 순차적으로 탐색해야 한다.

#### 요약
- 링크드 리스트는 노드들이 포인터로 연결된 자료구조라서 중간 삽입 또는 삭제가 빠르다.
- 하지만 인덱스로 바로 접근은 불가능해서 탐색은 느리다.

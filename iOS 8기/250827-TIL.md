# 👩🏻‍💻 2025.08.27 Today I Learned

# 📑 Findings

## 1. Escaping Closure
함수가 종료된 후에는 `@escaping` 키워드를 사용하며 실행시킨다. <br>
- 클로저는 기본적으로 `non-escaping`
- 비동기적인 작업 후 클로저를 호출할 때 사용한다.
<br>

```swift
func testEscapingClosure(closure: @escaping () -> void) {
}
```

<br>
<br>

## 2. Closure Capture
자신이 생성된 컨텍스트 내에 있는 변수나 상수에 접근
- 참조형식으로 값을 사용한다.
- 클로저가 선언된 뒤에 변수, 상수는 클로저 안에서 사용 불가

<br>
<br>

## 3. Capture List
클로저가 주변 환경 병수를 캡쳐할 때 메모리관리를 명시적으로 제어할 수 있는 방법
- 값타입으로 캡쳐 가능
- `Reference Type`은 참조 방식을 정할 수 있다.
  - 기본은 `strong`
  - `weak`, `unowned` 사용 가능
- 대괄호 안에 사용할 변수나 상수를 작성하여 캡쳐리스트를 정할 수 있다.

<br>
<br>

## 4. OOP, Object Oriented Programming
프로그램을 여러 개의 객체(Object)로 나누어 설계하고 구현하는 프로그래밍의 패러다임 <br>
클래스의 인스턴스를 사용해서 개발을 지향하는 프로그래밍 방식 <br>
- 재사용성과 유지보수성이 좋아짐

<br>

### 객체
`Class`를 사용해서 만들어진 인스턴스
- 상태(프로퍼티)
- 행동(메서드)
- 클래스의 인스턴스는 `일급객체`로 간주됨

<br>

### 4가지 특징
#### 1. 추상화
핵심 기능을 노출하고 불필요한 세부 사항을 숨김 <br>
복잡성을 줄이고 중요한 부분에만 집중

<br>

#### 2. 캡슐화
객체의 속성과 행동을 하나의 단위로 묶어서 관리하는 것
- 캡슐화
- 은닉화

<br>

#### 3. 상속
하위클래스가 상위클래스의 속성과 행동을 물려받아서 사용하는 것
- 하위클래스에서는 상위클래스에서 제공하는 연산 프로퍼티와 메서드를 **재정의(override)**하여 사용
- 상속받는 방법: `Class` 선언할 때 이름 뒤에 콜론 붙인 뒤 상속받을 클래스 이름 작성
- 클래스만 상속 가능
- `super` 키워드를 사용하여 상위클래스의 메서드나 프로퍼티에 접근 가능

<br>

#### 4. 다형성
같은 이름의 메서드가 다양한 방식으로 동작할 수 있는 특성
- 메서드 오버로딩(overloading): 파라미터의 타입이나 개수가 다르면 같은 이름의 메서드를 다른 메서드로 취급하는 방법
- 메서드 오버라이딩(Overriding)

<br>
<br>


## 5. Concurrency
한번에 여러 작업을 동시에 수행하는 것을 목표로 하는 프로그래밍 방식
- 하나의 프로세스에는 여러개의 스레드가 존재하며, 각 스레드에서 병렬 작업을 수행할 수 있다.

<br>

#### 메인 스레드
UI 작업을 할 수 있는 유일한 스레드

<br>

#### GCD, Grand Central Dispatch
<br>
iOS에서 제공하는 동시성 프로그래밍을 쉽게 처리하기 위한 도구
- `DispatchQueue`를 사용하여 여러 개의 스레드에 업무 분담
  - `Main Queue`
  - `Global Queue`

<br>


#### 1. `Main Queue`
메인 스레드로 작업을 전달
- 들어온 일을 하나씩 처리한다고 하여 직렬큐(Serial Queue)라고도 불린다.

<br>

```swift
DispatchQueue.main.async {

}
```

<br>


#### 2. `Global Queue`
들어온 여러가지의 작업을 동시에 처리할 수 있어 병렬큐(Concurrent Queue)라고도 불린다.

- `Global Queue`에 할 일을 추가하면 OS는 여러 개의 스레드에 작업을 나누어 처리
- 작업의 우선순위를 지정하는 Quality of Service, QoS를 설정할 수 있다.

- 우선순위
  - `.UserIntractive`
  - `.userInitiated`
  - `.default`
  - `.utility`
  - `.background`
  - `.unspecified`

<br>


```swift
DispatchQueue.global(qos: .background).async {
  // 사용자에게 보이지 않거나 중요하지 않은 작업
}
```

<br>

#### sync (동기)
- 작업이 순차적으로 실행
- 현재 작업이 끝날 때까지 다음 작업이 시작되지 않음 -> 대기시간 발생
- 디버깅 간편, 성능 저하 발생

<br>


#### async (비동기)
- 작업을 시작한 후 작업이 완료될 때까지 기다리지 않고 다음 코드를 바로 실행
- 여러 작업이 병행되어 빠른 처리 가능, 복잡한 코드

<br>
<br>

# 🧏🏻‍♀️ Insights
[BaseballGame Project](https://github.com/users/munuiee/projects/2)

어제부터 야구게임 구현하면서 나오는 에러들을 프로젝트 안 이슈에 기록하고 있다. <br>
항상 TIL에 합쳐 쓰곤 했는데 이렇게 하니 직관적이고 훨씬 편하다. <br>
프로젝트는 연습해볼겸 만들어서 사용 중인데 아직 알다가도 모르겠다. <br>
아무튼 남은 과제 파이팅










# 👩🏻‍💻 2025.08.26 Today I Learned:

# 📑 Findings

## 자료구조

### Array
- 메모리 공간에 연속적으로 데이터를 저장하는 자료구조
- 장점: 인덱스를 통한 빠른 접근 속도
- 단점: 배열 중간에 데이터를 추가하거나 삭제시 느린 속도

<br>

```swift
let array = [1, 2, 3, 5, 6, 7,8, 2]
```

<br>

#### 장점
시작 메모리 주소 0x1000 <br>
`Int` 배열이 하나에 8바이트를 먹는다고 가정했을 때 <br>
8 x 3 = 24 <br>
1000 + 24 = 1024 <br>
0x1024 주소에 있는 값이 array[3]을 한번에 찾아갈 수 있음 <br>

#### 단점
중간 데이터를 추가/삭제 할 때 느리다 <br>
```swift
array.remove(at: 2)
```

<br>

### Linked List
모리 공간에 연속적으로 데이터를 저장하지는 않지만, 각 데이터가 다음 데이터를 가리키는 포인터를 통해 연결되어 있어서 순서를 보장하는 자료구조

값과 다음 값의 주소를 저장하고 있다.

- 장점: 중간에 값을 추가하거나 삭제할 때 빠른 속도
- 단점: 
1. 추가적인 메모리 필요
	- 값과 다음 값의 주소를 같이 저장해야 함 (메모리공간 더 많이 차지)
2. 느린 인덱스 접근 속도

<br>
```swift
// linkedlist 3번째 인덱스에 접근해주세요!
```
- 0번째 인덱스로 이동(다음 주소값 확인) <br>
- 1번째 인덱스로 이동(다음 주소값 확인) <br>
- 2번째 인덱스로 이동(다음 주소값 확인) <br>
- 3번째 인덱스로 이동. 값을 얻었다! <br>

👉 인덱스만큼 이동해야 돼서 배열보다 인덱스 접근 속도가 느리다.


<br>

### Stack
선입후출(LIFO, Last IN First Out) 방식의 자료구조로, 먼저 들어간 데이터가 나중에 나오는 구조

- `push`를 이용해서 데이터를 추가
- `pop`을 이용해서 데이터를 제거

ex. 접시를 쌓아두는 방식과 유사하다. 맨 위에 쌓은 접시가 가장 먼저 꺼내진다.

<br>

### Queue
선입선출(FIFO, First In First Out) 방식의 자료구조로, 먼저 들어간 데이터가 먼저 나오는 구조

- `enqueue`를 사용해서 데이터를 추가
- `dequeue`를 사용해서 데이터를 제거

ex. 웨이팅 시 먼저 줄 선 사람이 먼저 들어가는 것과 유사

<br>
<br>

## 데이터 타입
### Value Type
데이터를 **복사**하여 사용되며, 값을 전달할 때 **참조가 아닌 복사**된 값이 전달된다. 
- `value type`의  인스턴스를 다른 변수나 상수에 할당하거나 메소드의 파라미터로 전달할 때, 실제 값의 복사본을 생성하여 전달한다. (원본을 할당하거나 전달하지 않는다)

<br>

### Reference Type
데이터를 직접 저장하지 않고 메모리주소를 저장하고 전달하여 사용
- `reference type`의 인스턴스를 다른 변수나 상수에 할당하거나 메서드의 파라미터로 전달할 때, 저장하고 있는 인스턴스의 실제 주소값을 전달한다.
- 주소값을 전달하기 때문에 전달받은 곳에서 값을 변경하면 원본의 값이 변경됨

<br>
<br>

## 메모리 구조

### 프로세스
실행중인 프로그램의 인스턴스
- iOS에서는 실행되는 앱을 프로세스라고 이해하면 된다.
- 앱이 실행되면, 운영 체제는 앱의 실행을 관리하기 위해서 프로세스를 생성함
- 프로세스는 자신만의 메모리 영역을 할당받고 앱의 실행상태를 관리함

<br>

### 메모리 구조
앱을 실행하면 운영체제가 메모리에 영역을 설정

<br>

#### `code` 영역
우리가 작성한 코드는 컴파일 과정을 거쳐 기계어 형태(0과 1)로 변환되어 이 영역에 저장된다.
- 프로그램 실행과 동시에 메모리에 할당되며, 프로그램이 종료되면 메모리에서 해제된다.
- `Read-Only(읽기전용)`으로 실행 중에는 변경 불가능

<br>

#### `Data` 영역
`전역변수`와 `정적(static)변수`가 저장되는 메모리 영역
- 프로그램 실행 시 메모리에 할당되며, 프로그램 종료 시 메모리에서 해제됨
- 프로그램 실행 중에 변수 값이 변경될 수 있으므로 `Read-Write(읽기-쓰기 가능)`이다.

<br>

#### `Heap` 영역
class 인스턴스나 클로저와 같은 `참조 타입(Reference Type)`의 데이터가 할당되는 동적 메모리 영역
- 이 영역의 메모리 크기는 런타임에 결정되며, 확정되지 않은 크기의 데이터가 저장된다.
- `ARC`를 통해서 메모리 관리가 자동으로 이루어짐

<br>

#### `Stack` 영역
함수 호출 시 생성되는 지역변수, 매개변수, 리턴값 등이 저장됨
- 일반적으로 `값 타입(value type)`의 데이터가 저장됨
- 함수가 종료되면 자동으로 메모리에서 해제
- 메모리 할당 및 해제의 속도가 `Heap` 영역보다 빠름
- `컴파일 시점`에 해당 영역의 메모리 크기가 결정됨
- Stack 메모리는 크기가 제한되어 있어, 이를 초과하면 스택 오버플로우(Stack Overflow) 오류가 발생하여 프로그램이 종료될 수 있다.

<br>

### `Copy On Write`
메모리 효율을 위해서 `value type`의 인스턴스를 다른 값에 할당하거나 파라미터로 전달할 때 값이 변경되기 전까지는 실제로 복사하지 않는 것

<br>
<br>

## ARC
Automatic Reference Couning <br>
`Reference Type`의 인스턴스 메모리 관리를 자동으로 해주는 기능 (`Value Type`의 인스턴스는 `ARC`가 관리하지 않음)
- 메모리 관리를 직접 하지 않아도 `ARC`가 자동으로 메모리 관리를 처리
	
    - 인스턴스가 더이상 필요하지 않을 때 메모리에서 자동으로 해제됨
- `Reference Type`의 인스턴스를 참조할 때, 참조카운트가 증가하며, 이를 `strong` 참조라고 한다. (`default`)

- 참조카운트의 증가를 원하지 않는 경우 `weak` 또는 `unowned` 참조를 사용할 수 있다.

<br>
<br>

---

# 🗝️ Key takeaways
오늘 Class 특강을 들었다. Class에 대해 어느정도 알게 됐다고 생각을 했는데.. 아니었던 것 같다. 

### 🧳가 있다면?

- Class
    - 캐리어를 만드는 설계도
    - 어떤 속성(손잡이, 바퀴)과 기능(잠금)이 있는지 설계
- Instance
    - 실제로 제작된 캐리어
    - 캐리어를 사용하는 것은 실제로 만들어서 사용하는 것 ( = 설계도를 사용하는 게 아님)
    

<br>
클래스와 인스턴스의 관계가 가끔 헷갈렸는데 이렇게 예시로 공부했더니 바로 이해가 되었다. <br>

### 클래스 사용하기

- 클래스는 `{ }` 사이에 내용을 작성한다.
    - 내용은 프로퍼티, 메서드, 이니셜라이저 등
- 작성한 클래스의 기능을 사용하려면 인스턴스로 만들어야 한다.
    - 인스턴스를 통해 해당 기능을 사용한다
    - 괄호, 중괄호의 의미보다는 무엇을 사용하는 방법의 약속이라고 생각하기
    
<br>

똑같은 클래스를 받아도 인스턴스는 다르다는 것을 알게 되었다.
<br>
가장 이해가 안 됐던 부분은 `let cal = Calculator()`를 하나는 AppDelegate에 하나는 ViewController에 쓰고 두 개의 인스턴스가 다르다고 했던 것이다. <br>
튜터님께 따로 여쭤봤더니 이런 답변을 받았다 ! <br>

Q. `let cal = Calculator()` 는 상수명이 같은데 왜 다른 건가요? <br>

A. 같은 이름이어도 코드가 실행되고 다뤄지는 위치가 다르다. 중괄호를 기준으로 봄. 소속되어있는 곳이 아예 다름. 어떤 곳은 함수, 어떤 곳은 클래스.. 실행 위치가 아예 다르므로 다르다!

<br>

이제껏 Class를 공부하면서 이렇게까지 깊이 알진 못했다. (안 물어봤으면 평생 모를 뻔!) Scope에 대해서 알아봐도 좋다고 하시길래 공부를 더 해봤다.

<br>

### scope❓

변수나 상수에 접근할 수 있는 코드의 영역 <br>

변수는 코드에서 선언이 되어야, 그 이하의 코드에 접근이 가능하다.<br>

상위 스코프에서 선언된 변수와 상수에 접근 가능하며, 하위 스코프에는 접근할 수 없다.<br>

기준은 중괄호 `{ }`<br>

중괄호 내에서 밖에 있는 변수는 접근이 가능하다.<br>

하지만 밖에서 중괄호 내의 변수로 접근이 불가능하다.<br>

#### 종류

1. 전역 범위 (Global Scope)
2. 지역 범위 (Local Scope)
<br>
이 두 가지를 나누는 기준은 중괄호
<br>

### 전역 범위

```swift
var globalValue = 10

func printGlobal() {
		print("전역 값: \(globalValue)")
}

printGlobal() // 10
globalValue = 20
printGlobal() // 20
```

<br>

어디서든 `globalValue` 에 접근 가능!

<br>

### 지역 범위

```swift
func localExample() {
	let localValue = 5
	print("지역 값: \(localValue)")
}

localExample() // 5
print(localValue) // Error. localValue는 함수 밖에서는 모름
```

<br>

`localValue` 는 함수 안에서만 살아있고, 함수가 끝나면 메모리에서 사라짐.

<br>

### 전역 + 지역

```swift
var number = 100 // 전역 변수

func scopeTest() {
	let number = 50 // 지역 변수 (전역과 같은 이름)
	print("함수 안 number: \(number)")
}

scopeTest() // 50 (지역 변수가 우선)
print("함수 밖 number: \(number)") // 100 
```

<br>

#### 과제하면서 만난 에러
`Missing arguments for parameters 'name', 'age' in call ` <br>
`init`으로 생성자를 정의했는데 인스턴스를 출력할 때 파라미터를 삽입하지 않아서 발생한 오류였다. <br>

`init`을 정의할 경우 `let person = Person(name: "지혜",  age: 20)` 반드시 값을 추가해야 하고, 기본값을 준 경우에는 `let person = Person()` 이렇게 아무 값도 주지 않아도 된다.

---


# 🧏🏻‍♀️ Git Insights

실습 과제 업로드 때문에 오랜만에 깃 브랜치 생성 작업을 하였다. <br>

`git init` 
- 해당 폴더에 .git 파일 생성됨


 
`git remote add origin [GitHub 주소]` 
- 깃허브 주소와 연결



`git branch [브랜치명]` 
- 브랜치 생성

`git checkout -b [브랜치명]`
- 해당 브랜치로 이동

`git branch`
- 원하는 브랜치로 이동했는지 확인

`git add .`
- 파일 또는 폴더를 추가하기 '.' 대신 파일 주소 작성해도 된다.

`git commit -m "커밋 메세지"`
- 커밋하기

`git push origin [브랜치명]`
- 원하는 브랜치로 Push

[git에 관한 기록들](https://velog.io/@jihyee10/git-터미널)

<br>

#### fatal: not a valid object name: 'main'  
오늘 만난 에러.. `main` 브랜치가 없는데 거기서 뭔갈 하려고 해서 나온다고 한다. 처음 만든 리포라 커밋이 없어서 그런 것 같다.

<br>

```
git add .
git commit -m "chore: initial commit"
git branch -m main   # 이때 main으로 이름 바꿈
```

<br>
아무 브랜치가 없으므로.. 초기 커밋

<br>

그리고 오늘 처음으로 **브랜치 이름 수정**을 시도해보았다. 수정할 브랜치로 위치 설정을 해주고 
<br>

```
git push origin 새이름
git push --set-upstream origin 새이름
```

<br>
그리고 옛 이름 브랜치도 삭제해준다. <br>


```
git push origin :옛브랜치
```



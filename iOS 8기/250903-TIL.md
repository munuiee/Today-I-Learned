# (๑'ㅅ')✎ 2025.09.03 Today I Learned:

## Review𓈒 𓂂𓏸
드디어 코드베이스 UI를 공부했다. 어제 스탠다드반 특강 때 코드베이스를 활용한 `UITableView` 만들기 특강을 들었는데, 들을 때는 대강 이해했던 게 끝나고 하나도 기억에 남지 않았다... 일단 코드가 되게 복잡하게 느껴지고 기억해야할 게 너무 많아서 어려웠다. 기초부터 쌓고 싶어서 스토리보드 UI 강의를 먼저 듣고 코드베이스로 넘어갔다. 강의로 차근차근 기초부터 공부하니 조금씩 알게 되는 것 같다. 아직 멀었지만, 코드베이스의 기반을 잡는 코드들은 어느정도 알게되었다.

그리고 오늘 깃 이슈 때문에 상당히 애먹었는데, 결론은 터미널 그만 사용하고 크라켄 이용하자! 그리고 깃을 완전히 알기 전까지, 익숙해지기 전까지는 폴더도 함부로 생성하지 말자! 라는 것을 깨닫다...

<br>

## 💁🏻‍♀️ᩚ Insights

## 1. 코드베이스 UI

### 1. 코드베이스 기초
#### 코드베이스 준비하기

1. `main.storyboard` 삭제
2. `info.plist`에서 main을 받는 스토리보드 삭제
3. 타겟 멤버십 Build Settings에서 main을 받는 파일 삭제
4. `SceneDelegate` 수정

- 앱에 반드시 한 개는 필요한 가장 근본이 되는 뷰 `var window: UIWindow?`

- 앱을 시작할 때 세팅해줄 코드를 작성하는 곳
```swift
func scene(_ scene: UIScene, willConnectTo Session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
	guard let windowScene = (scene as? UIWindowScene) else { return }
    let window = UIWindow(windowScene: windowScene)
    
    window.rootViewController = ViewController()
    window.makeKeyAndVisible()
    
    self.window = window
```

<br>

<코드 하나하나 뜯어보기>

- `UIWindowScene` 객체 생성
	
    - `UIWindowScene`으로 타입 캐스팅 (`as?`)
    - 타입 캐스팅 실패시 nil 반환, 리턴하여 함수 종료
    ```swift
    guard let windowScene = (scene as? UIWindowScene) else { return }
    ```

<br>

- `window`에게 루트 뷰 컨트롤러 지정
```swift
window.rootViewController = ViewController()
```

<br>

- 이 메서드를 반드시 실행해줘야 윈도우가 활성화 됨
```swift
window.makeKeyAndVisible()
```


<br>

### 2. AutoLayout - `NSLayoutConstraint`
- `변수명.translatesAutoresizingMaskIntoConstraints = false`: 오토레이아웃 활성화
- Constraint: 뷰와 뷰 사이의 제약조건
    - `leadingAnchor`
    - `trailingAnchor`
    - `topAnchor`
    - `bottomAnchor`
    - `widthAnchor`
    - `heightAnchor`
    - `centerXAnchor`: x축 한가운데
    - `centerYAnchor`: Y축 한가운데
- `NSLayoutContraint.activate([제약조건들])`: 제약조건들을 넣고 코드 작성

```swift
NSLayoutConstraint.activate([
   imageView.widthAnchor.constraint(equalToConstant: 300),
	 imageView.heightAnchor.constraint(equalToConstant: 300),
   imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor),
   imageView.centerYAnchor.constraint(equalTo: view.centerYAnchor)
])
```

<br>
<br>

### 3. UILabel
- `let label = UILabel()`로 선언
- `configureUI` 메서드 정의
- `view`는 `VieController`가 기본적으로 갖고 있는 view
- `view.addSubview(label)`로 view에 label 추가

<br>
<br>

### 4. Snapkit
Snapkit 설치는 타겟 멤버십 General 프레임워크 추가에서!

- `변수명.translateAutoresizingMaskIntoconstraints = false` 이 코드는 불필요함
- `NSLayoutConstraint.activate` → `SnapKit` 문법으로 작성

```swift
label.snp.makeConstraints { make in
	make.width.equalTo(80)
	make.height.equalTo(40)
	make.centerX.equalToSuperview() // view = superview
	make.centerY.equalToSuperview()
}
```

<br>

- $0으로도 대체 가능

```swift
label.snap.makeConstriants {
	$0.width.equalTo(80)
	$0.height.equalTo(40)
}
```

<br>

- `centerX`, `centerY` 한번에 쓰기

```swift
$0.center.equalToSuperview()
```

<br>

- `width`, `height` 같은 값이면

```swift
$0.width.height.equalTo(300)
```

<br>
<br>

### 5. @objc
- 코드로 액션 넣기 → `addTarget()`
- `#selector()`안에 넣기 위해서는 `@objc`

```swift
@objc private func buttonClicked() {
	print("버튼이 클릭되었음! 'ㅅ'")
}
```

```swift
private func configureUI() {
	button.addTarget(self, action: #selector(buttonClicked), for: .touchDown)
}
```

<br>
<br>

### 6. `view.addSubview()`를 여러개 입력해야 하는 경우
순회돌면서 추가됨
```swift
[firstView, secondView, thirdView ...]
	.forEach { view.addSubview($0) }
```

<br>
<br>

### 7. 그외의 키워드들

- 이미지와 라벨 사이 오토레아

```swift
$0.top.equalTo(imageView.snp.bottom).offset(10)
```

`label`의 top은 `imageView`의 bottom과 같되, 10만큼 떨어진다.

<br>

- leading과의 마진

```swift
$0.leading.equalToSuperview().offset(16)
```

`SuperView()` 와 같이 가져가되 16만큼 떨어뜨린다.

<br>

- 이미지뷰랑 라벨 맞추기

```swift
label.snp.makeConstraints {
  $0.centerX.equalTo(imageView.snp.centerX)
}
```

이미지뷰의 centerX에 라벨을 맞춘다.

<br>
<br>

### 8. `offset`과 `inset`

- `offset`: 비교하는 대상으로부터 왼 → 오, 아래 → 위일 때 양수로 작용. 반대는 음수(차라리 `inset`을 써라)
- `inset`: `superview`와 나와의 거리

<br>

<br>

---

## 2. UITableView
실습 과제로 UITableView를 코드베이스 바탕으로 만들었는데 감이 전혀 안 잡혀서 한참을 헤맸다. 

> **FirstViewController**

```swift
tableView.dataSource = self
tableView.delegate = self
```
`dataSource`와 `delegate` 연결해주면

```swift
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return datas.count
    }
    
    func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: FirstTableViewCell.identifier, for: indexPath ) as? FirstTableViewCell
        else { return .init() }
        
        let data = datas[indexPath.row]
        cell.configure(data: data)
        return cell
    }
```

이런 함수가 생성된다.

<br>

```swift
func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -> Int {
        return datas.count
    }
```
- `numberOfRowsInSection` 셀의 개수 카운팅
- `return datas.count` datas의 개수만큼 카운트

<br>

```swift
 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -> UITableViewCell {
        guard let cell = tableView.dequeueReusableCell(withIdentifier: FirstTableViewCell.identifier, for: indexPath ) as? FirstTableViewCell
        else { return .init() }
        
        let data = datas[indexPath.row]
        cell.configure(data: data)
        return cell
    }
```

- `indexPath`: 현재 몇 번째 섹션의 몇 번째 행(`row`)인지
- 셀의 재사용 `dequeueReusableCell`
- `indexPath.row`: 현재 행 번호로 해당 데이터 꺼냄

<br>

```swift
self.tableView.register(FirstTableViewCell.self, forCellReuseIdentifier: FirstTableViewCell.identifier)
```
셀을 등록하는 코드

- `register(_:forCellReuseIdentifier:)`: identifier 등록
- `forCellReuseIdentifier: FirstTableViewCell.identifier`: 셀을 구분하기 위해 붙이는 재사용 식별자. 커스텀 셀 내부에 `static`으로 오타 방지

<br>

> **FirstTableViewCell**

```swift
func configureUI() {
        contentView.addSubview(dataLabel)
    }
```
`contentView`로 추가

<br>

```swift
override init(style: UITableViewCell.CellStyle, reuseIdentifier: String?) {
        super.init(style: style, reuseIdentifier: reuseIdentifier)
        configureUI()
        tableSetting()
    }
```
셀이 처음 생성될 때 실행되는 생성자(init) <br>
셀을 만들 때 반드시 구현해야 하는 코드!

<br>

```super.init(style:reuseIdentifier:)```

부모 클래스(UITableViewCell)의 초기화 과정을 먼저 실행. <br>
반드시 첫 줄에 호출해야 함. <br>
안 하면 런타임 에러 발생.

<br>

```swift
required init?(coder: NSCoder) {
    fatalError("init(coder:) has not been implemented")
}
```
반드시 추가해야하는 초기화 메서드

<br>
<br>

## 3. 오늘의 Git ISSUE
오늘 내 하루의 반을 앗아가버린 생전 처음 겪어본 요상한 에러


#### 왜 자꾸 또다른 경로의 파일이 Push 되는지 🤨
터미널에 pwd 명령어를 입력해서 경로 확인을 해도, 프로젝트 폴더에서 직접 터미널을 열어도 왜자꾸만 다른 프로젝트 파일이 전부 업로드가 되는 건지 이유를 알 수 없었고, 튜터님께 여쭤본 결과 gitignore을 생성해보라고 하셨다.

그런데 이걸 해도 해결이 되지 않았고.. gitignore과 함께 다른 프로젝트 파일이 함께 올라가게 되었다.
다시 튜터님께 여쭤보았고 깃크라켄으로 확인한 결과 완전완전 브랜치가 꼬여있는 것을 발견.

원인은.. 폴더가 많아지는 게 보기 싫어 한 폴더에 (주제별로 정리하긴 했다..😭) 때려박은 게 잘못이었던 것 같다. 그리고 자꾸만 터미널을 쓰던 게 문제였다. 

자세한 내용은 깃 이슈에서 → [왜 자꾸 또다른 경로의 파일이 Push 되는지](https://github.com/munuiee/StandardClassProject/issues/1)

## escaping closure

기본적으로 함수의 파라미터로 전달된 클로저는 함수 내부에서만 사용할 수 있지만, 함수가 종료된 후에도 실행해야 할 경우에는 `@escaping` 키워드를 사용한다.

- 클로저의 타입 앞에 `@escaping` 키워드 명시
- 클로저는 기본적으로 `non-escaping`
    - 파라미터로 받은 클로저는 함수의 실행이 완료되기 전에 함수 내부에서 클로저를 사용해야 한다.
    - 파라미터로 받은 클로저는 다른 변수나 상수에 할당할 수 없다.

```swift
// 정상적인 클로저
func testEscapingClosure(closure: () -> Void) {
	closure()
}

testEscapingClosure {
	print("Hello")
} // Hello
```

```swift
// 함수가 실행된 후 파라미터로 받은 클로저가 사용되는 경우
import UIKit
func testEscapingClosure(closure: () -> Void) {
	// 1초 뒤에 클로저 호출
	DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
		closure()
	}
}

// 함수가 끝나고 1초 뒤에 클로저를 호출하기 때문에 오류 발생
```

```swift
// 파라미터로 받은 클로저는 다른 변수나 상수에 할당할 수 없다.
func testEscapingclosure(closure: () -> Void) {
	let newClosure: () -> Void = closure // Error
}
```

- 비동기적인 작업 후 클로저를 호출할 때 주로 `@escaping closure` 를 사용한다.
    - 예시
        - 서버에서 API를 호출하는 경우 서버의 응답을 기다린 후 데이터를 받아 처리
        - 이때, 서버에서 응답이 도착하기 전에 함수가 먼저 종료될 수 있음
        - 함수가 종료된 이후에도 클로저를 실행할 수 있도록 `@escaping` 을 사용하여 서버의 응답을 받은 후에 클로저를 호출한다.

```swift
import UIKit

func testEscapingClosure(closure: @escaping () -> Void) {
	
	// 1초 뒤에 코드블록을 실행하는 코드
	DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) {
		closure()
	}
}

testEscapingClosure {
	print("클로저 실행")
}
```

### 클로저 캡처 (Closure Capture)

클로저는 자신이 생성된 컨텍스트(자신이 생성된 코드 블록) 내에 있는 변수나 상수에 접근할 수 있다.

- `참조 형식` 으로 값을 사용한다. 즉 값이 변경되면 캡쳐된 값도 변경된 값을 출력
- 클로저가 선언된 뒤에 선언된 변수, 상수는 클로저 안에서 사용 불가

```swift
struct Person {
	var name: String
	var age: Int
}

func testClosureCapture() {
	var person = Person(name: "Ganadi", age: 1)

// swift에서 중괄호(`{ }`) = 코드블록
	let closure = {
		// 해당 클로저에서 person을 캡쳐하여 사용
		// 값 타입이기 때문에 나이 1을 복사하여 사용
		// 값이 1, 1이 나오지 않는 이유: 기본적으로 클로저 캡쳐는 '참조형식'이므로
		
		print(peron.age)
	}
	closure() // 1
	
	person.age = 2
	
	closure() // 2
}

testClosureCapture()
```

```swift
// 클로저 캡쳐는 클로저 사용 전에 선언된 변수나 상수만 가능

func testClosureCaptureError() {
	var a = 1
	
	let closure = {
		print(a)
		print(b) // Error: 클로저 생성된 후의 b를 캡처할 수 없음
		
	}
	var b = 1
}
```

### 캡처 리스트

클로저가 주변 환경 변수를 캡처할 때 메모리관리를 명시적으로 제어할 수 있는 방법

- `value type`의 값도 참조로 캡처하지만 `value type`으로 캡처할 수 있다.
- `reference type`은 참조방식을 정할 수 있다.
- `[ ]` 대괗로 안에 사용할 변수나 상수를 작성하여 캡처리스트를 정할 수 있다.

`reference type` 참조 방식 정하기

- 기본은 `strong` → 강한순환참조가 발생할 수 있음
- 대괄호를 사용하고 참조방식과 캡처할 변수(상수) 이름을 작성
- `weak`, `unownd` 사용 가능

```swift
class Animal {
	var name: String
	var age: Int
	
	init(name: String, age: Int) {
		self.name = name
		self.age = age
	}
}

func testClosureCaptureReference() {
	var animal = Animal(name: "Dog", age: 1)
	
	let closure = { [weak animal] in // [ ]
		print(animal?.age)
	}
	
	closure() // Optional(1)
	animal.age = 2
	closure() // Optional(2)
```

`value type` 으로 캡처하는 방법

- 대괄호를 작성하고 캡처할 변수(상수) 작성

```swift
struct Person {
	var name: String
	var age: Int
}

func testClosureCapture() {
	var person = Person(name: "Ganandi", age: 3)
	var a = 1
	
	let closure = { [person] in 
		print(person.age)
		print(a)
	}
	closure() // 3
	person.age = 5
	a = 
	closure() // 3
}

testClosureCapture()
```

# 네트워크

## RESTful API메서드
### RESTful API?
: 서버와 클라이언트 간 데이터를 주고 받기 위한 표준화된 방법을 정의한 것
- 주로 JSON이나 XML 통해 데이터를 주고 받으며, 의도에 맞는 HTTP 메서드를 사용한다.
- 주로 사용되는 HTTP 메서드
  - `GET`: 서버에서 데이터를 읽어올 때 
    - 쿼리스트링으로 데이터를 전달한다.
      - URL 뒤에 `?`를 붙인 후 `key=value` 형태로 데이터를 보낸다.
      - 여러개의 데이터를 보낼 때는 `&`을 사용하여 구분한다.

  - `POST`: 새로운 데이터 생성을 요청할 때
    - `Body`에 데이터를 담아서 요청한다.

  - `PUT`: 기존 데이터를 수정하거나 업데이트 할 때
    - `Body`에 데이터를 담아서 요청한다.
   
  - `PATCH`: 기존 데이터의 일부를 수정할 때
    - `Body`에 데이터를 담아서 요청

  - `DELETE`: 데이터 삭제를 요청할 때
 
<br>
<br>

## URLSession 주요 구성 요소
```swift
import Foundation

func fetchPosts() {
  print("Starting API Call")

  let task = URLSession.shared.dataTask(with: URL(string: "https://blahblah.com")

    if let error = error {
        print(error.localizedDescription)
        return
    }

    guard let data = data else {
        print("No data")
        return
    }

    // data를 사용하여 작업 진행
    print("API Success Do Something with Data")
  }

  task.resume() // 작업 시작

  print("API Call Started")
}

fetchPosts()

// 출력값
/*
Starting API Call
API Call Strated
API Success Do Something with Data

API가 호출되고 네트워크를 통해 서버에서 값을 받아오는 시간이 존재하여 클로저가마지막에 호출됨
*/
```

<br>

- `URLSessionTask`
  - 위 코드에서 `URLSession.shared.dataTask(...)`의 반환 타입으로 서버에 데이터를 요청하는 비동기 작업을 담당
  - `dataTask(with:)` 메소드는 URL을 통해 데이터를 요청하고, 클로저 내부에서 서버의 응답을 처리한다.
  - `task.resume()`은 실제로 네트워크 요청을 시작하는 부분이다. `URLSessionTask`는 기본적으로 멈춘 상태에서 시작되기 때문에 `resume()`을 호출해줘야 작업이 진행된다.

- `URLSessionConfiguration`
  - 위 코드에서는 `URLSession.shared`를 사용하여 기본 설정을 가진 세션을 사용하고 있다.
  - 만약 타임아웃, 캐시 정책 등을 설정하고 싶다면 `URLSessionConfiguration`을 사용해 별도로 세션을 구성할 수 있다.

 <br>
 
  ```swift
  import Foundation

  let confit = URLSessionConfiguration.default
  config.timeoutIntercalForReaquest = 30.0
  let session = URLSession(configuration: config)
  ```


<br>
<br>

## Result Type
비동기 작업이나 에러가 발생할 수 있는 작업의 결과를 명확하게 처리하기 위해 사용되는 열거형(enum)
- 작업이 성공했을 때와 실패했을 때의 결과를 한번에 처리할 수 있도록 설계되어, 코드의 가독성을 높이고 에러처리를 직관적이게 할 수 있다.

```swift
@frozen public enum Result<Success, Failure> where Failure: Error {
  // A success, storing a `Success` value.
  case success(Success)

   // A failure, storing a `Failure` value.
  case failure(Failure)
```

<br>

 - `success`, `failure` 두 가지로 정의되어 있다.
   - 제네릭으로 되어있어서 동적으로 사용이 가능하며 Failure는 Error 프로토콜을 따르는 타입만 사용 가능하다.

<br>

```swift
import Foundation

func divide(_ numerator: Int, by denominator: Int) -> Result<Int, Error> {
  guard denominator != 0 else {
    return .failure(NSError(domain: "나누기오류", code: 1, userInfo: [NSLocalizedDescriptionKey: "0으로 나눌 수 없어요!"]))
  }
  return .success(numerator / denominator)
}

let result = divide(10, by: 2)

switch result {
case .success(let value):
  print("Result is \(value)")
case .failure(let error):
  print("Failed with error: \(error.localizedDescription)")
}

let errorResult = divide(5, by: 0)
switch errorResult {
case . success(let value):
  print("Result is \(value)")
case .failure(let error):
  print("Failed with error: \(error.localizedDescription)")
}

/* 결과값
Result is 5
Failed with error: 0으로 나눌 수 없어요!
*/
```

<br>
<br>

## 네트워크에서 자주 사용되는 protocol `Codable`
서버에서 전송된 문자 형식의 데이터를 Swift 인스턴스로 변환하거나, Swift 인스턴스를 서버에 전송할 형식(JSON, XML)으로 변환을 도와주는 프로토콜

```swift
public typealias Codable = Decodable & Encodable
```

<br>

- `Codable`
  - `Decodable`: JSON, XML의 데이터형식을 Swift 인스턴스로 디코딩(병렬화)할 수 있게 함
  - `Encodable`: Swift 인스턴스를 JSON, XML 데이터 형식으로 인코딩(직렬화)할 수 있게 함
 
<br>

### 사용 방법
#### `Encodable`
여러 개의 값을 갖고 있는 객체를 한 줄의 JSON 데이터로 변경한다고 생각하기
<br>

```swift
import Foundation

struct Person: Codable { // Codable을 채택한 Person 구조체 선언
  let name: String
  let age: Int
}

let person = Person(name: "Brody", age: 20)
if let jsonData = try? JSONEncoder().encode(person),
   let jsonString = String(data: jsonData, encoding: .utf8) {
      print(jsonString) // { "age": 20, "name": "Brody" }
}
```

<br>

#### `Decodable`
한 줄로 길게 저장되어 있는 JSON 데이터를 여러 개의 값을 갖고 있는 객체로 병렬화한다고 생각하기
```swift
import Fundation

struct Person: Codable { // Codable을 채택한 Person의 구조체를 선언
  let name: String
  let age: Int
}

let jsonString = """
  { "age": 20, "name": "Brody" }
"""

if let jsonData = jsonString.data(using: .utf8),
   let person = try? JSONDecoder().decode(Person.self, from: jsonData) {
      print(person) // Person(name: "Brody", age: 20)
}
```


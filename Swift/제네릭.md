# 제네릭
함수나 타입을 정의할 때 구체적인 데이터 타입을 명시하지 않고, 나중에 사용하는 시점에서 타입을 지정할 수 있게 해주는 기능

<br>

- 제네릭을 사용하면 Swift에서 다양한 타입에 대한 유연하고 **재사용** 가능한 코드를 작성할 수 있다.
- 중복 코드를 줄이고 명확하고 추상적인 방식으로 표현
- 하나의 `함수`, `구조체`, `클래스`, `열거형` 등이 여러 타입에서 작동할 수 있도록 만들 수 있다.
- `< >` 안에 있는 이름이 범용으로 사용할 타입의 이름, 나중에 사용할 때 구체적인 타입이 정해진다.

<br>

- 컬렉션 타입에서의 제네릭

```swift
@frozen public struct Array<Element> {}
```

<br>

- 함수에서의 제네릭

```swift
// 두 값을 비교하는 제네릭 함수
// 제네릭타입을 T로 만들어서 어떤 타입이든 받을 수 있게 처리
func swapTwoValues<T>(_ a: inout T, _ b: inout T) {
  let temporaryA = a
  a = b
  b = temporaryA
}

var a = 10
var b = 20
swapTwoValues(&a, &b)
print("a: \(a), b: \(b)") // a: 20, b: 10

var x = "Hello"
var y = "World"
swapTwoValues(&x, &y)
print("x: \(x), y: \(y)")) // x: World, y: Hello
```

<br>

- 구조체에서의 제네릭

```swift
struct Stack<Element> {
  var items: [Element] = []

  mutating func push(_ item: Element) {
    items.append(item)
  }

  mutating func pop() -> Element? {
    return items.popLast()
  }
}

var intStack = Stack<Int>()
intStack.push(10)
intStack.push(20)
print(intStack.pop()!) // 20

var stringStack = Stack<String>()
stringStack.push("Hello")
stringStack.push("World")
print(stringStack.pop()!) // World

// 스택을 만드는 순간 타입이 정해짐

```

<br>
<br>

## 제네릭 제약
제네릭은 모든 타입에 대해 작동할 수 있지만, 특정 조건을 부여하여 제약을 걸 수 있다.
- 특정 프로토콜을 준수하거나, 특정 클래스의 하위 클래스에서만 허용할 수 있다.

```swift
// Comparable을 준수하는 타입만 허용
func findMinimumValue2<T>(array: [T]) -> T? where T : Comparable {
    guard !array.isEmpty else { return nil }
    return array.min()
}

// Comparable을 준수하는 타입만 허용
func findMinimumValue<T: Comparable>(in array: [T]) -> T? {
    guard !array.isEmpty else { return nil }
    return array.min()
}

let intArray = [3, 1, 4, 1, 5, 9]
if let minValue = findMinimumValue(in: intArray) {
    print("Minimum value: \(minValue)") // Minimum value: 1
}

let stringArray = ["Apple", "Banana", "Cherry"]
if let minValue = findMinimumValue(in: stringArray) {
    print("Minimum value: \(minValue)") // Minimum value: Apple
}
```

# `Array` 배열
- 메모리 공간에 **연속적으로 데이터를 저장**하는 자료구조
- 장점: 인덱스를 통한 빠른 접근 속도
- 단점: 배열 중간에 데이터를 추가하거나 삭제시 느린 속도

<br>

```swift
let array = [1, 2, 3, 5, 6, 7,8, 2]
```

![](https://velog.velcdn.com/images/jihyee10/post/77e3ff90-030e-4cce-8587-3ab395e62c45/image.png)

```swift
array[3]
```

#### 장점
시작 메모리 주소 0x1000 <br>
`Int` 배열이 하나에 8바이트를 먹는다고 가정했을 때 <br>
8 x 3 = 24 <br>
1000 + 24 = 1024 <br>
0x1024 주소에 있는 값이 array[3]을 한번에 찾아갈 수 있음 <br>

#### 단점
중간 데이터를 추가/삭제 할 때 느리다
```swift
array.remove(at: 2)
```

![](https://velog.velcdn.com/images/jihyee10/post/a9f246c6-9fc7-4053-a17a-f6839db2c75e/image.png)
- 2번째 인덱스에 값을 삭제
![](https://velog.velcdn.com/images/jihyee10/post/6e2ea2ed-f713-49a0-b363-0f50bf04e6b6/image.png)

- 뒤에 5,6,7,8,2를 앞으로 한칸씩 앞으로 땡김.

<br>
<br>

# Linked List
메모리 공간에 연속적으로 데이터를 저장하지는 않지만, 각 데이터가 **다음 데이터를 가리키는 포인터를 통해 연결**되어 있어서 순서를 보장하는 자료구조

값과 다음 값의 주소를 저장하고 있다.
![](https://velog.velcdn.com/images/jihyee10/post/f37f7ffc-090e-4063-b251-ae17c6eb369d/image.png)

- 장점: 중간에 값을 추가하거나 삭제할 때 빠른 속도
- 단점: 
1. 추가적인 메모리 필요
	- 값과 다음 값의 주소를 같이 저장해야 함 (메모리공간 더 많이 차지)
2. 느린 인덱스 접근 속도
```swift
// linkedlist 3번째 인덱스에 접근해주세요!
```
- 0번째 인덱스로 이동(다음 주소값 확인)
- 1번째 인덱스로 이동(다음 주소값 확인)
- 2번째 인덱스로 이동(다음 주소값 확인)
- 3번째 인덱스로 이동. 값을 얻었다!

👉 인덱스만큼 이동해야 돼서 배열보다 인덱스 접근 속도가 느리다.

<br>
<br>

# Stack
선입후출(LIFO, Last IN First Out) 방식의 자료구조로, **먼저 들어간 데이터가 나중에 나오는 구조**

- `push`를 이용해서 데이터를 추가
- `pop`을 이용해서 데이터를 제거

ex. 접시를 쌓아두는 방식과 유사하다. 맨 위에 쌓은 접시가 가장 먼저 꺼내진다.

![](https://velog.velcdn.com/images/jihyee10/post/ffb42734-08b1-4552-a02a-7f3d1d833490/image.png)


<br>
<br>

# Queue
선입선출(FIFO, First In First Out) 방식의 자료구조로, **먼저 들어간 데이터가 먼저 나오는 구조**

- `enqueue`를 사용해서 데이터를 추가
- `dequeue`를 사용해서 데이터를 제거

ex. 웨이팅 시 먼저 줄 선 사람이 먼저 들어가는 것과 유사
